unit uRoughPlanningCont;interfaceuses  LCLproc,LCLIntf,LCLType,LMessages, SysUtils,Classes, Graphics, Controls,  Forms, Dialogs, ExtCtrls, StdCtrls, Grids, Spin, ComCtrls, Buttons,  EditBtn,dateutils,Calendar;const  crGanttMiddle = 16345;  crGanttRightMove = 16346;  crGanttLeftMove = 16347;  crGanttPercent = 16348;  crGanttConnect = 16349;const  SCROLL_MAX = 100;  SCROLL_MINSTEP = 1;  SCROLL_MAXSTEP = 10;type  TTimeScale = (tsMinute, tsHour, tsDay, tsWeek,tsWeekNum,tsWeekNumPlain, tsMonth, tsQuarter, tsHalfYear, tsYear);type  TIntervalType = (itPeriod, itAction);  TIntervalStyle = (isDefault,isNone);const  PrevScale: array[TTimeScale] of TTimeScale =    (tsMinute, tsMinute, tsHour, tsDay, tsDay, tsDay,tsDay, tsMonth, tsMonth, tsMonth);type  TDragIntervalType = (ditMiddle, ditRightMove, ditLeftMove, ditPercent, ditConnect, ditNone);type  TGanttColumnType =  (    gctInfo, gctTask, gctDuration, gctStart,    gctFinish, gctConnection, gctResources, gctNone  );type  TPaitBackgroundEvent = procedure(Sender : TObject;Canvas : TCanvas;aRect : TRect;aStart,aEnd : TDateTime;aDayWidth : Double) of object;  TRoughCalendar = class;  TRoughTree = class;  TRough = class;  TRoughCalendar = class(TCustomControl)  private    FVertScrollBar: TScrollBar;    FHorzScrollBar: TScrollBar;    FMajorScale: TTimeScale;    FMinorScale: TTimeScale;    FPixelsPerMinorScale: Integer;    FPixelsPerLine: Integer;    FStartDate: TDateTime;    FVisibleStart: TDateTime;    FCurrentDate: TDateTime;    FMajorColor: TColor;    FMinorColor: TColor;    FIntervals: TList;    FRough: TRough;    FBeforeStartDateCount: Integer;    FDragRect: TRect;    FDragType: TDragIntervalType;    FDragStarted: Boolean;    FFromDragPoint: Integer;    FConnectFromPoint: TPoint;    FConnectToPoint: TPoint;    // Property Procedures and functions    procedure SetMajorScale(const Value: TTimeScale);    procedure SetMinorScale(const Value: TTimeScale);    procedure SetPixelsPerMinorScale(const Value: Integer);    procedure SetPixelsPerLine(const Value: Integer);    procedure SetStartDate(const Value: TDateTime);    function GetVisibleFinish: TDateTime;    function GetMinorVisibleUnitsCount: Integer;    function GetMajorScale: Integer;    function GetMinorScale: Integer;    function GetSeconds: Integer;    function GetMinutes: Integer;    function GetHours: Integer;    function GetDays: Integer;    function GetDayOfWeek: Integer;    function GetWeeks: Integer;    function GetMonthes: Integer;    function GetQuarters: Integer;    function GetHalfYears: Integer;    function GetYears: Integer;    function GetTimeUnitByScale(ATimeScale: TTimeScale): Integer;    procedure SetMajorColor(const Value: TColor);    procedure SetMinorColor(const Value: TColor);    // Other usefull methods    procedure DrawHeaderLines;    procedure DrawMinorScale;    procedure DrawMajorScale;    function IsNewPeriod(AScale: TTimeScale; AUseSub: Boolean = False): Boolean;    procedure UpdateScrollbars;    procedure DoOnHorzScroll(Sender: TObject; ScrollCode: TScrollCode; var ScrollPos: Integer);    procedure WMSize(var Message: TLMSize);      message LM_SIZE;    procedure CMMouseEnter(var Message: TLMessage);      message CM_MOUSEENTER;    procedure CMMouseLeave(var Message: TLMessage);      message CM_MOUSELEAVE;    procedure WMMouseMove(var Message: TLMMouseMove);      message LM_MOUSEMOVE;    procedure WMLButtonDown(var Message: TLMLButtonDown);      message LM_LBUTTONDOWN;    procedure WMLButtonUp(var Message: TLMRButtonDown);      message LM_LBUTTONUP;  protected    procedure Paint; override;  public    constructor Create(AnOwner: TRough); reintroduce;    destructor Destroy; override;    function GetStartDrawIntervals: Integer;    function GetIntervalHeight: Integer;    function GetIntervalWidth: Double;    property Seconds: Integer read GetSeconds;    property Minutes: Integer read GetMinutes;    property Hours: Integer read GetHours;    property Days: Integer read GetDays;    property DayOfWeek: Integer read GetDayOfWeek;    property Weeks: Integer read GetWeeks;    property Monthes: Integer read GetMonthes;    property Quarters: Integer read GetQuarters;    property HalfYears: Integer read GetHalfYears;    property Years: Integer read GetYears;    property TimeUnitByScale[ATimeScale: TTimeScale]: Integer read GetTimeUnitByScale;    property StartDrawIntervals: Integer read GetStartDrawIntervals;    property IntervalHeight: Integer read GetIntervalHeight;    property MinorVisibleUnits: Integer read GetMinorVisibleUnitsCount;    property MajorScaleHeight: Integer read GetMajorScale;    property MinorScaleHeight: Integer read GetMinorScale;    property VisibleStart: TDateTime read FVisibleStart;    property VisibleFinish: TDateTime read GetVisibleFinish;  published    property Font;    property Color;    property Align;    property MajorColor: TColor read FMajorColor write SetMajorColor;    property MinorColor: TColor read FMinorColor write SetMinorColor;    property MajorScale: TTimeScale read FMajorScale write SetMajorScale default tsWeek;    property MinorScale: TTimeScale read FMinorScale write SetMinorScale default tsDay;    property PixelsPerMinorScale: Integer read FPixelsPerMinorScale write SetPixelsPerMinorScale default 30;    property PixelsPerLine: Integer read FPixelsPerLine write SetPixelsPerLine default 24;    property StartDate: TDateTime read FStartDate write SetStartDate;    property OnMouseMove;    property OnMouseDown;    property OnMouseUp;    property OnDblClick;    property OnClick;  end;  TRoughTree = class(TStringGrid)  private    FAfterUpdateCommonSettings: TNotifyEvent;    FIntervals: TList;    FRough: TRough;    FIndent: Integer;    FBranchFont: TFont;    FTextEdit: TEdit;    FDurationEdit: TSpinEdit;    FDateEdit: TDateEdit;    FComboEdit: TComboBox;    FUpDown: TUpDown;    FMonthCalendar: TCalendar;    FDownButton: TSpeedButton;    // property procedures and functions    function GetColumnType(AnIndex: Integer): TGanttColumnType;    procedure SetAfterUpdateCommonSettings(AValue: TNotifyEvent);    procedure SetIndent(const Value: Integer);    procedure DrawMinus(X, Y: Integer);    procedure DrawPlus(X, Y: Integer);    function GetBrachFont: TFont;    procedure SetBranchFont(const Value: TFont);    // other usefull procedures and functions    procedure OnEditKeyPress(Sender: TObject; var Key: Char);    procedure OnEditExit(Sender: TObject);    procedure OnDownButtonClick(Sender: TObject);    procedure OnMonthCalendarClick(Sender: TObject);    procedure OnUpDownButtonClick(Sender: TObject; Button: TUDBtnType);    procedure UpdateCurrentControl(ACol, ARow: Integer);    procedure ShowTaskEditor;    procedure WMChar(var Message: TLMChar);      message LM_CHAR;  protected    procedure CreateWnd; override;    procedure DrawCell(ACol, ARow: Longint; ARect: TRect;      AState: TGridDrawState); override;    procedure MouseDown(Button: TMouseButton;      Shift: TShiftState; X, Y: Integer); override;    function SelectCell(ACol, ARow: Longint): Boolean; override;    procedure TopLeftChanged; override;    procedure ColWidthsChanged; override;    procedure DoExit; override;    procedure UpdateCommonSettings;    procedure UpdateTreeList;  public    constructor Create(AnOwner: TRough); reintroduce;    destructor Destroy; override;  published    property Indent: Integer read FIndent write SetIndent;    property Font;    property BranchFont: TFont read GetBrachFont write SetBranchFont;    property AfterUpdateCommonSettings : TNotifyEvent read FAfterUpdateCommonSettings write SetAfterUpdateCommonSettings;  end;  TRough = class(TCustomControl)  private    FIntervals: TList;    FCalendar: TRoughCalendar;    FTree: TRoughTree;    FSplitter: TSplitter;    FUpdateCount : Integer;    function GetCalendarFont: TFont;    procedure SetCalendarFont(const Value: TFont);    function GetCalendarColor: TColor;    procedure SetCalendarColor(const Value: TColor);    function GetMajorColor: TColor;    procedure SetMajorColor(const Value: TColor);    function GetMinorColor: TColor;    procedure SetMinorColor(const Value: TColor);    function GetMajorScale: TTimeScale;    procedure SetMajorScale(const Value: TTimeScale);    function GetMinorScale: TTimeScale;    procedure SetMinorScale(const Value: TTimeScale);    function GetPixelsPerMinorScale: Integer;    procedure SetPixelsPerMinorScale(const Value: Integer);    function GetPixelsPerLine: Integer;    procedure SetPixelsPerLine(const Value: Integer);    function GetStartDate: TDateTime;    procedure SetStartDate(const Value: TDateTime);    function GetTreeIndent: Integer;    procedure SetTreeIndent(const Value: Integer);    function GetTreeFont: TFont;    procedure SetTreeFont(const Value: TFont);    function GetTreeBranchFont: TFont;    procedure SetTreeBranchFont(const Value: TFont);  protected  public    constructor Create(AnOwner: TComponent); override;    destructor Destroy; override;    procedure MakeIntervalList(AList: TList);    procedure UpdateInterval;    property Tree: TRoughTree read FTree;    property Calendar: TRoughCalendar read FCalendar;    procedure BeginUpdate;    function IsUpdating : Boolean;    procedure EndUpdate;  published    property Align;    property CalendarFont: TFont read GetCalendarFont write SetCalendarFont;    property CalendarColor: TColor read GetCalendarColor write SetCalendarColor;    property MajorColor: TColor read GetMajorColor write SetMajorColor;    property MinorColor: TColor read GetMinorColor write SetMinorColor;    property MajorScale: TTimeScale read GetMajorScale write SetMajorScale default tsWeek;    property MinorScale: TTimeScale read GetMinorScale write SetMinorScale default tsDay;    property PixelsPerMinorScale: Integer read GetPixelsPerMinorScale write SetPixelsPerMinorScale default 30;    property PixelsPerLine: Integer read GetPixelsPerLine write SetPixelsPerLine default 24;    property StartDate: TDateTime read GetStartDate write SetStartDate;    property TreeIndent: Integer read GetTreeIndent write SetTreeIndent;    property TreeFont: TFont read GetTreeFont write SetTreeFont;    property TreeBranchFont: TFont read GetTreeBranchFont write SetTreeBranchFont;  end;//procedure Register;function UnitsBetweenDates(Start, Finish: TdateTime; TimeScale: TTimeScale): Double;function GetTimeScaleName(TimeScale: TTimeScale; D: TDateTime): String;function IncTime(D: TDateTime; TimeScale: TTimeScale; IncAmount: Integer): TDateTime;function ClearToPeriodStart(MinorScale: TTimeScale; D: TDateTime): TDateTime;implementation{$R gsGantt.res}uses Math;resourcestring  strDay                     = ' Tage';  strNum                     = 'Pos';  strInfo                    = 'Info';  strTask                    = 'Aufgabe';  strTime                    = 'Dauer';  strStart                   = 'Start';  strFinish                  = 'Ende';  strTies                    = 'Ties';  strResourses               = 'Resourcen';  strKW                      = 'KW';var  DrawBitmap: TBitmap = nil;{  --------------------------------------------------------  ------                                            ------  ------      Usefull procedures and functions      ------  ------                                            ------  --------------------------------------------------------}function GetTimeScaleUnits(TimeScale: TTimeScale; Year, Month: Integer): Integer;begin  case TimeScale of    tsMinute:    begin      Result := 60;    end;    tsHour:    begin      Result := 60;    end;    tsDay:    begin      Result := 24;    end;    tsWeek,tsWeekNum,tsWeekNumPlain:    begin      Result := 7;    end;    tsMonth:    begin      Result := MonthDays[IsLeapYear(Year)][Month];    end;    tsQuarter:    begin      Result := 3;    end;    tsHalfYear:    begin      Result := 2;    end;    tsYear:    begin      Result := 2;    end;    else      Result := 60;  end;end;function IncTime(D: TDateTime; TimeScale: TTimeScale; IncAmount: Integer): TDateTime;var  S: TTimeStamp;begin  S := DateTimeToTimeStamp(D);  case TimeScale of    tsMinute:    begin      if IncAmount > 24 * 60 then      begin        Inc(S.Date, IncAmount div 24 * 60);        IncAmount := IncAmount - IncAmount div (24 * 60) * (24 * 60);      end;      Inc(S.Time, IncAmount * 60 * 1000);      while S.Time < 0 do      begin        Dec(S.Date);        S.Time := MSecsPerDay + S.Time;      end;    end;    tsHour:    begin      if IncAmount > 24 then      begin        Inc(S.Date, IncAmount div 24);        IncAmount := IncAmount - IncAmount div 24 * 24;      end;      Inc(S.Time, IncAmount * 60 * 60 * 1000);      while S.Time < 0 do      begin        Dec(S.Date);        S.Time := MSecsPerDay + S.Time;      end;    end;    tsDay:    begin      Inc(S.Date, IncAmount);    end;    tsWeek,tsWeekNum,tsWeekNumPlain:    begin      Inc(S.Date, IncAmount * 7);    end;    tsMonth:    begin      S := DateTimeToTimeStamp(IncMonth(D, IncAmount));    end;    tsQuarter:    begin      S := DateTimeToTimeStamp(IncMonth(D, IncAmount * 3));    end;    tsHalfYear:    begin      S := DateTimeToTimeStamp(IncMonth(D, IncAmount * 6));    end;    tsYear:    begin      S := DateTimeToTimeStamp(IncMonth(D, IncAmount * 12));    end;    else begin      if IncAmount > 24 * 60 * 60 then      begin        Inc(S.Date, IncAmount div 24 * 60 * 60);        IncAmount := IncAmount - IncAmount div 24 * 60 * 60;      end;      Inc(S.Time, IncAmount * 1000);      while S.Time < 0 do      begin        Dec(S.Date);        S.Time := MSecsPerDay + S.Time;      end;    end;  end;  Result := TimeStampToDateTime(S);end;function IncTimeEx(D: TDateTime; TimeScale: TTimeScale; IncAmount: Double): TDateTime;var  S: TTimeStamp;  Year, Month, Day: Word;begin  S := DateTimeToTimeStamp(D);  case TimeScale of    tsMinute:    begin      if IncAmount > 24 * 60 then      begin        Inc(S.Date, Trunc(IncAmount / 24 * 60));        IncAmount := IncAmount - Trunc(IncAmount / 24 * 60) * (24 * 60);      end;      Inc(S.Time, Trunc(IncAmount * 60 * 1000));      while S.Time < 0 do      begin        Dec(S.Date);        S.Time := MSecsPerDay + S.Time;      end;    end;    tsHour:    begin      if IncAmount > 24 then      begin        Inc(S.Date, Trunc(IncAmount / 24));        IncAmount := IncAmount - Trunc(IncAmount / 24) * 24;      end;      Inc(S.Time, Trunc(IncAmount * 60 * 60 * 1000));      while S.Time < 0 do      begin        Dec(S.Date);        S.Time := MSecsPerDay + S.Time;      end;    end;    tsDay:    begin      Inc(S.Date, Trunc(IncAmount));      S :=        DateTimeToTimeStamp        (          IncTimeEx          (            TimeStampToDateTime(S), tsHour, Frac(IncAmount) * 24          )        );    end;    tsWeek,tsWeekNum,tsWeekNumPlain:    begin      Inc(S.Date, Trunc(IncAmount) * 7);      S :=        DateTimeToTimeStamp        (          IncTimeEx          (            TimeStampToDateTime(S), tsDay, Frac(IncAmount) * 7          )        );    end;    tsMonth:    begin      S := DateTimeToTimeStamp(IncMonth(D, Trunc(IncAmount)));      DecodeDate(TimeStampToDateTime(S), Year, Month, Day);      S :=        DateTimeToTimeStamp        (          IncTimeEx          (            TimeStampToDateTime(S), tsDay,            Frac(IncAmount) * MonthDays[IsLeapYear(Year)][Month]          )        );    end;    tsQuarter:    begin      S := DateTimeToTimeStamp(IncMonth(D, Trunc(IncAmount) * 3));      S :=        DateTimeToTimeStamp        (          IncTimeEx          (            TimeStampToDateTime(S), tsMonth, Frac(IncAmount) * 3          )        );    end;    tsHalfYear:    begin      S := DateTimeToTimeStamp(IncMonth(D, Trunc(IncAmount) * 6));      S :=        DateTimeToTimeStamp        (          IncTimeEx          (            TimeStampToDateTime(S), tsMonth, Frac(IncAmount) * 6          )        );    end;    tsYear:    begin      S := DateTimeToTimeStamp(IncMonth(D, Trunc(IncAmount) * 12));      S :=        DateTimeToTimeStamp        (          IncTimeEx          (            TimeStampToDateTime(S), tsMonth, Frac(IncAmount) * 12          )        );    end;    else begin      if IncAmount > 24 * 60 * 60 then      begin        Inc(S.Date, Trunc(IncAmount / 24 * 60 * 60));        IncAmount := IncAmount - IncAmount / 24 * 60 * 60;      end;      Inc(S.Time, Trunc(IncAmount * 1000));      while S.Time < 0 do      begin        Dec(S.Date);        S.Time := MSecsPerDay + S.Time;      end;    end;  end;  Result := TimeStampToDateTime(S);end;function ClearToPeriodStart(MinorScale: TTimeScale; D: TDateTime): TDateTime;var  S: TTimeStamp;  Year, Month, Day: Word;begin  S := DateTimeToTimeStamp(D);  DecodeDate(D, Year, Month, Day);  case MinorScale of    tsMinute:    begin      S.Time := (S.Time div (60 * 1000)) * (60 * 1000);    end;    tsHour:    begin      S.Time := (S.Time div (60 * 60 * 1000)) * (60 * 60 * 1000);    end;    tsDay:    begin      S.Time := 0;    end;    tsWeek,tsWeekNum,tsWeekNumPlain:    begin      S.Date := (S.Date div 7) * 7 + 1;      S.Time := 0;    end;    tsMonth:    begin      Day := 1;      D := EncodeDate(Year, Month, Day);      S := DateTimeToTimeStamp(D);      S.Time := 0;    end;    tsQuarter:    begin      Day := 1;      Month := (Month div 3) * 3 + 1;      if Month > 12 then      begin        Month := 1;        Inc(Year);      end;      D := EncodeDate(Year, Month, Day);      S := DateTimeToTimeStamp(D);      S.Time := 0;    end;    tsHalfYear:    begin      Day := 1;      Month := (Month div 6) * 6 + 1;      if Month > 12 then      begin        Month := 1;        Inc(Year);      end;            D := EncodeDate(Year, Month, Day);      S := DateTimeToTimeStamp(D);      S.Time := 0;    end;    tsYear:    begin      Day := 1;      Month := 1;      D := EncodeDate(Year, Month, Day);      S := DateTimeToTimeStamp(D);      S.Time := 0;    end;    else begin      S.Time := (S.Time div 1000) * 1000;    end;  end;  Result := TimeStampToDateTime(S);end;function GetTimeScaleName(TimeScale: TTimeScale; D: TDateTime): String;var  Hour, Min, Sec, MSec: Word;  Year, Month, Day: Word;  S: TTimeStamp;begin  DecodeDate(D, Year, Month, Day);  DecodeTime(D, Hour, Min, Sec, MSec);  S := DateTimeToTimeStamp(D);  case TimeScale of    tsMinute:    begin      Result := IntToStr(Min);    end;    tsHour:    begin      Result := IntToStr(Hour);    end;    tsDay:    begin      Result := ShortDayNames[DayOfWeek(D)];    end;    tsWeek:    begin      Result := IntToStr(Day) + '.' + IntToStr(Month);    end;    tsWeekNum:    begin      Result := strKW+IntToStr(WeekOfTheYear(D));    end;    tsWeekNumPlain:    begin      Result := IntToStr(WeekOfTheYear(D));    end;    tsMonth:    begin      Result := ShortMonthNames[Month];    end;    tsQuarter:    begin      Result := IntToStr((Month) div 3 + 1);    end;    tsHalfYear:    begin      Result := IntToStr((Month) div 6 + 1);    end;    tsYear:    begin      Result := IntToStr(Year);    end;  end;end;function UnitsBetweenDates(Start, Finish: TdateTime; TimeScale: TTimeScale): Double;var  StartStamp, FinishStamp: TTimeStamp;  StartDay, StartMonth, StartYear: Word;  FinishDay, FinishMonth, FinishYear: Word;begin  StartStamp := DateTimeToTimeStamp(Start);  FinishStamp := DateTimeToTimeStamp(Finish);    DecodeDate(Start, StartYear, StartMonth, StartDay);  DecodeDate(Finish, FinishYear, FinishMonth, FinishDay);  case TimeScale of    tsMinute:    begin      Result :=        (FinishStamp.Time / 1000 / 60 + FinishStamp.Date * 24 * 60) -        (StartStamp.Time / 1000 / 60 + StartStamp.Date * 24 * 60);    end;    tsHour:    begin      Result :=        (FinishStamp.Time / 1000 / 60 / 60 + FinishStamp.Date * 24) -        (StartStamp.Time / 1000 / 60 / 60 + StartStamp.Date * 24);    end;    tsDay:    begin      Result :=        (FinishStamp.Time / 1000 / 60 / 60 / 24 + FinishStamp.Date) -        (StartStamp.Time / 1000 / 60 / 60 / 24 + StartStamp.Date);    end;    tsWeek,tsWeekNum,tsWeekNumPlain:    begin      Result :=        (FinishStamp.Time / 1000 / 60 / 60 / 24 / 7 + FinishStamp.Date / 7) -        (StartStamp.Time / 1000 / 60 / 60 / 24 / 7 + StartStamp.Date / 7);    end;    tsMonth:    begin      Result :=        (          FinishMonth            +          (FinishDay + FinishStamp.Time / 1000 / 60 / 60 / 24)            /          MonthDays[IsLeapYear(FinishYear)][FinishMonth]        )          -        (          StartMonth            +          (StartDay + StartStamp.Time / 1000 / 60 / 60 / 24)            /          MonthDays[IsLeapYear(FinishYear)][FinishMonth]        )          +        (FinishYear - StartYear)          *        12;    end;    tsQuarter:    begin      Result :=        (          (            FinishMonth              +            (FinishDay + FinishStamp.Time / 1000 / 60 / 60 / 24)              /            MonthDays[IsLeapYear(FinishYear)][FinishMonth]          )            -          (            StartMonth              +            (StartDay + StartStamp.Time / 1000 / 60 / 60 / 24)              /            MonthDays[IsLeapYear(FinishYear)][FinishMonth]          )        )          /        3          +        (FinishYear - StartYear)          *        3;    end;    tsHalfYear:    begin      Result :=        (          (            FinishMonth              +            (FinishDay + FinishStamp.Time / 1000 / 60 / 60 / 24)              /            MonthDays[IsLeapYear(FinishYear)][FinishMonth]          )            -          (            StartMonth              +            (StartDay + StartStamp.Time / 1000 / 60 / 60 / 24)              /            MonthDays[IsLeapYear(FinishYear)][FinishMonth]          )        )          /        6          +        (FinishYear - StartYear)          *        6;    end;    tsYear:    begin      Result :=        (          (            FinishMonth              +            (FinishDay + FinishStamp.Time / 1000 / 60 / 60 / 24)              /            MonthDays[IsLeapYear(FinishYear)][FinishMonth]          )            -          (            StartMonth              +            (StartDay + StartStamp.Time / 1000 / 60 / 60 / 24)              /            MonthDays[IsLeapYear(FinishYear)][FinishMonth]          )          /          12        )          +        (FinishYear - StartYear);    end;    else begin      Result :=        FinishStamp.Time / 1000 + FinishStamp.Date * 24 * 60 * 60 -        StartStamp.Time / 1000 + StartStamp.Date * 24 * 60 * 60;    end;  end;end;function IsInRect(X, Y: Integer; R: TRect): Boolean;begin  Result := (X >= R.Left) and (X <= R.Right) and (Y >= R.Top) and (Y <= R.Bottom);end;procedure WriteText(ACanvas: TCanvas; ARect: TRect; DX, DY: Integer;  const Text: string; Alignment: TAlignment; ARightToLeft: Boolean);const  AlignFlags : array [TAlignment] of Integer =    ( DT_LEFT or DT_WORDBREAK or DT_EXPANDTABS or DT_NOPREFIX,      DT_RIGHT or DT_WORDBREAK or DT_EXPANDTABS or DT_NOPREFIX,      DT_CENTER or DT_WORDBREAK or DT_EXPANDTABS or DT_NOPREFIX );  RTL: array [Boolean] of Integer = (0, DT_RTLREADING);var  B, R: TRect;  Hold, Left: Integer;  I: TColorRef;begin  I := ColorToRGB(ACanvas.Brush.Color);  if {GetNearestColor(ACanvas.Handle, I) = I} False then  begin                       { Use ExtTextOut for solid colors }    { In BiDi, because we changed the window origin, the text that does not      change alignment, actually gets its alignment changed. }    case Alignment of      taLeftJustify:        Left := ARect.Left + DX;      taRightJustify:        Left := ARect.Right - ACanvas.TextWidth(Text) - 3;    else { taCenter }      Left := ARect.Left + (ARect.Right - ARect.Left) shr 1        - (ACanvas.TextWidth(Text) shr 1);    end;    ACanvas.TextRect(ARect, Left, ARect.Top + DY, Text);  end  else begin                  { Use FillRect and Drawtext for dithered colors }    DrawBitmap.Canvas.Lock;    try      with DrawBitmap, ARect do { Use offscreen bitmap to eliminate flicker and }      begin                     { brush origin tics in painting / scrolling.    }        Width := Max(Width, Right - Left);        Height := Max(Height, Bottom - Top);        R := Rect(DX, DY, Right - Left - 1, Bottom - Top - 1);        B := Rect(0, 0, Right - Left, Bottom - Top);      end;      with DrawBitmap.Canvas do      begin        Font := ACanvas.Font;        Font.Color := ACanvas.Font.Color;        Brush := ACanvas.Brush;        Brush.Style := bsSolid;        FillRect(B);        SetBkMode(Handle, TRANSPARENT);        DrawText(Handle, PChar(Text), Length(Text), R,          AlignFlags[Alignment] or RTL[ARightToLeft]);      end;      ACanvas.CopyRect(ARect, DrawBitmap.Canvas, B);    finally      DrawBitmap.Canvas.Unlock;    end;  end;end;constructor TRoughCalendar.Create(AnOwner: TRough);begin  inherited Create(AnOwner);  FVertScrollBar := TScrollBar.Create(Self);  FVertScrollBar.Kind := sbVertical;  FVertScrollBar.Enabled := True;  FVertScrollBar.Visible := True;  FVertScrollBar.Align := alRight;  FVertScrollBar.TabStop := False;  InsertControl(FVertScrollBar);  FHorzScrollBar := TScrollBar.Create(Self);  FHorzScrollBar.Kind := sbHorizontal;  FHorzScrollBar.Enabled := True;  FHorzScrollBar.Visible := True;  FHorzScrollBar.Align := alBottom;  FHorzScrollBar.TabStop := False;  InsertControl(FHorzScrollBar);  FHorzScrollBar.SetParams(0, 0, SCROLL_MAX);  FHorzScrollBar.LargeChange := SCROLL_MAXSTEP;  FHorzScrollBar.PageSize := SCROLL_MAXSTEP;  FHorzScrollBar.SmallChange := SCROLL_MINSTEP;  FVertScrollBar.SetParams(0, 0, SCROLL_MAX);  FVertScrollBar.LargeChange := SCROLL_MAXSTEP;  FVertScrollBar.PageSize := SCROLL_MAXSTEP;  FVertScrollBar.SmallChange := SCROLL_MINSTEP;  FMajorScale := tsMonth;  FMinorScale := tsWeek;  FStartDate := Now;  FCurrentDate := 0;  FVisibleStart := ClearToPeriodStart(MinorScale, FStartDate);  FPixelsPerMinorScale := 30;  FPixelsPerLine := 20; {24}  Color := clWhite;  FMajorColor := clBtnFace;  FMinorColor := clBtnFace;  FIntervals := AnOwner.FIntervals;  FRough := AnOwner;  FBeforeStartDateCount := 0;  FDragRect := Rect(-1, -1, -1, -1);  FDragType := ditNone;  FDragStarted := False;  FFromDragPoint := 0;  FConnectFromPoint := Point(0, 0);  FConnectToPoint := Point(0, 0);end;destructor TRoughCalendar.Destroy;begin  inherited Destroy;end;procedure TRoughCalendar.Paint;var  ClipRgn: hRgn;  List: TList;  I, K: Integer;  BMP: TBitmap;  DoneRect: TRect;  aTop: Integer;begin  aTop := FRough.Tree.TopRow-1;  ClipRgn := CreateRectRgn  (    0,    0,    Width - FVertScrollBar.Width * Integer(FVertScrollBar.Visible),    Height - FHorzScrollBar.Height * Integer(FHorzScrollBar.Visible)  );  List := TList.Create;  BMP := TBitmap.Create;  BMP.Width := 2;  BMP.Height := 2;  BMP.Canvas.Pixels[0, 0] := clBlue;  BMP.Canvas.Pixels[1, 1] := clBlue;  BMP.Canvas.Pixels[0, 1] := Color;  BMP.Canvas.Pixels[1, 0] := Color;  try    SelectClipRgn(Canvas.Handle, ClipRgn);    Brush.Color := Color;    Canvas.FillRect(Rect(      0, Width - FVertScrollBar.Width * Integer(FVertScrollBar.Visible),      0, Height - FHorzScrollBar.Height * Integer(FHorzScrollBar.Visible)));    Canvas.Brush.Color := FMajorColor;    Canvas.FillRect(Rect(0, 0, Width, MajorScaleHeight));    Canvas.Brush.Color := FMajorColor;    Canvas.FillRect(Rect(0, MajorScaleHeight, Width, MajorScaleHeight + MinorScaleHeight));    FRough.MakeIntervalList(List);//    for I := 0 to List.Count - 1 do//      TInterval(List[I]).ClearDrawRect;    FCurrentDate := VisibleStart;    while FCurrentDate < VisibleFinish do    begin      DrawMinorScale;      FCurrentDate := IncTime(FCurrentDate, MinorScale, 1);    end;    FCurrentDate := ClearToPeriodStart(MajorScale, VisibleStart);    while FCurrentDate < VisibleFinish do    begin      DrawMajorScale;      FCurrentDate := IncTime(FCurrentDate, MajorScale, 1);    end;{    for I := aTop to List.Count - 1 do TInterval(List[I]).PrepareDrawRect;    for I := aTop to List.Count - 1 do      if Assigned(TInterval(List[I]).FBP) then        TInterval(List[I]).FBP(TInterval(List[I]),Canvas,Rect(0,(I-aTop) * PixelsPerLine + 1 + StartDrawIntervals,Width,((I-aTop) * PixelsPerLine)+PixelsPerLine+StartDrawIntervals+1),VisibleStart,VisibleFinish,UnitsBetweenDates(VisibleStart,VisibleStart+1,MinorScale)*PixelsPerMinorScale);}    DrawHeaderLines;{    for I := aTop to List.Count - 1 do    begin      CurrInterval := TInterval(List[I]);      if not CurrInterval.IsDrawRectClear then      begin        with Canvas do        begin          if (CurrInterval.IntervalType = itAction) and (CurrInterval.Style = isDefault) then          begin            CurrInterval.Top := (I-aTop) * PixelsPerLine + 1 + StartDrawIntervals + PixelsPerLine div 2 - PixelsPerLine div 4;            CurrInterval.Bottom := CurrInterval.Top + PixelsPerLine div 4 * 2;            CurrInterval.Left := CurrInterval.Left - PixelsPerLine div 4;            CurrInterval.Right := CurrInterval.Right + PixelsPerLine div 4;            Brush.Color := clBlue;            with CurrInterval.DrawRect do              Polygon              (                [                  Point(Left + (Right - Left) div 2, Top),                  Point(Right, Top + (Bottom - Top) div 2),                  Point(Left + (Right - Left) div 2, Bottom),                  Point(Left, Top + (Bottom - Top) div 2),                  Point(Left + (Right - Left) div 2, Top)                ]              );            Brush.Color := clBlue;            Brush.Style := bsClear;            Pen.Color := clBlack;            Pen.Style := psSolid;            //Ellipse(CurrInterval.DrawRect);            with CurrInterval.DrawRect do              Polygon              (                [                  Point(Left + (Right - Left) div 2, Top),                  Point(Right, Top + (Bottom - Top) div 2),                  Point(Left + (Right - Left) div 2, Bottom),                  Point(Left, Top + (Bottom - Top) div 2),                  Point(Left + (Right - Left) div 2, Top)                ]              );            Brush.Style := bsSolid;            Brush.Color := clBlue;          end else if (CurrInterval.IsCollection) and (CurrInterval.Style = isDefault) then          begin            CurrInterval.Top := (I-aTop) * PixelsPerLine + 1 + StartDrawIntervals;            CurrInterval.Bottom := (I-aTop) * PixelsPerLine + 1 + StartDrawIntervals + 4;            CurrInterval.Left := CurrInterval.Left - 4;            CurrInterval.Right := CurrInterval.Right + 4;            Brush.Color := clBlack;            Brush.Style := bsSolid;            FillRect(CurrInterval.DrawRect);            with CurrInterval.DrawRect do            begin              Polygon              (                [                  Point(Left, Bottom),                  Point(Left + 4, Bottom + 4),                  Point(Left + 8, Bottom)                ]              );              Polygon              (                [                  Point(Right - 1, Bottom),                  Point(Right - 5, Bottom + 4),                  Point(Right - 9, Bottom)                ]              );            end;          end else if (CurrInterval.Style = isDefault) then begin            CurrInterval.Top := (I-aTop) * PixelsPerLine + StartDrawIntervals + IntervalHeight div 4;            CurrInterval.Bottom := ((I-aTop) + 1) * PixelsPerLine + StartDrawIntervals - IntervalHeight div 4;            Brush.Color := clBlue;            Brush.Bitmap := BMP;            FillRect(CurrInterval.DrawRect);            Brush.Bitmap := nil;            Brush.Color := clBlue;            Brush.Style := bsSolid;            FrameRect(CurrInterval.DrawRect);            if CurrInterval.IntervalDone > CurrInterval.StartDate then            begin              DoneRect := CurrInterval.DoneRect;              Brush.Style := bsSolid;              Brush.Color := clBlack;              FillRect(DoneRect);            end;          end;        end;      end;    end;  for I := aTop to List.Count - 1 do  begin    CurrInterval := TInterval(List[I]);    for K := 0 to CurrInterval.ConnectionCount - 1 do      ConnectIntervals(CurrInterval, CurrInterval.Connection[K]);  end;}  finally    BMP.Free;    List.Free;    SelectClipRgn(Canvas.Handle, 0);    DeleteObject(ClipRgn);  end;end;{  ************************  ***   Private Part   ***  ************************}procedure TRoughCalendar.SetMajorScale(const Value: TTimeScale);begin  if csReading in ComponentState then    FMajorScale := Value  else if Value < MinorScale then    raise Exception.Create('MajorScale should by higher than MinorScale')  else if Value = MinorScale then    raise Exception.Create('MajorScale should by different from MinorScale')  else begin    FMajorScale := Value;    Invalidate;  end;end;procedure TRoughCalendar.SetMinorScale(const Value: TTimeScale);begin  if csReading in ComponentState then    FMinorScale := Value  else if Value > MajorScale then    raise Exception.Create('MinorScale should by lower than MajorScale')  else if Value = MajorScale then    raise Exception.Create('MinorScale should by different from MajorScale')  else begin    FMinorScale := Value;    Invalidate;  end;end;procedure TRoughCalendar.SetPixelsPerMinorScale(const Value: Integer);begin  if Value < 10 then    FPixelsPerMinorScale := 10  else    FPixelsPerMinorScale := Value;  FRough.UpdateInterval;end;procedure TRoughCalendar.SetPixelsPerLine(const Value: Integer);begin  if Value < 1 then    FPixelsPerLine := 1  else    FPixelsPerLine := Value;  FRough.UpdateInterval;end;procedure TRoughCalendar.SetStartDate(const Value: TDateTime);begin  FStartDate := Value;  FVisibleStart := ClearToPeriodStart(MinorScale, FStartDate);  Invalidate;end;function TRoughCalendar.GetVisibleFinish: TDateTime;begin  Result := IncTime(VisibleStart, MinorScale, MinorVisibleUnits + 1);end;function TRoughCalendar.GetMinorVisibleUnitsCount: Integer;begin  Result := ClientWidth div PixelsPerMinorScale;  Inc(Result, Integer(ClientWidth mod PixelsPerMinorScale <> 0));end;function TRoughCalendar.GetMajorScale: Integer;begin  Canvas.Font := Font;  Result := Trunc(Canvas.TextHeight('A') * 1.5);end;function TRoughCalendar.GetMinorScale: Integer;begin  Canvas.Font := Font;  Result := Trunc(Canvas.TextHeight('A') * 1.5);end;function TRoughCalendar.GetSeconds: Integer;var  Hour, Min, Sec, MSec: Word;begin  DecodeTime(FCurrentDate, Hour, Min, Sec, MSec);  Result := Sec;end;function TRoughCalendar.GetMinutes: Integer;var  Hour, Min, Sec, MSec: Word;begin  DecodeTime(FCurrentDate, Hour, Min, Sec, MSec);  Result := Min;end;function TRoughCalendar.GetHours: Integer;var  Hour, Min, Sec, MSec: Word;begin  DecodeTime(FCurrentDate, Hour, Min, Sec, MSec);  Result := Hour;end;function TRoughCalendar.GetDays: Integer;var  Year, Month, Day: Word;begin  DecodeDate(FCurrentDate, Year, Month, Day);  Result := Day;end;function TRoughCalendar.GetDayOfWeek: Integer;var  S: TTimeStamp;begin  S := DateTimeToTimeStamp(FCurrentDate);  Result := (S.Date - 1) mod 7 + 1;end;function TRoughCalendar.GetWeeks: Integer;var  S: TTimeStamp;begin  S := DateTimeToTimeStamp(FCurrentDate);  Result := (S.Date - 1) div 7;end;function TRoughCalendar.GetMonthes: Integer;var  Year, Month, Day: Word;begin  DecodeDate(FCurrentDate, Year, Month, Day);  Result := Month;end;function TRoughCalendar.GetQuarters: Integer;var  Year, Month, Day: Word;begin  DecodeDate(FCurrentDate, Year, Month, Day);  Result := Month div 3 + 1;end;function TRoughCalendar.GetHalfYears: Integer;var  Year, Month, Day: Word;begin  DecodeDate(FCurrentDate, Year, Month, Day);  Result := Month div 6 + 1;end;function TRoughCalendar.GetYears: Integer;var  Year, Month, Day: Word;begin  DecodeDate(FCurrentDate, Year, Month, Day);  Result := Year;end;function TRoughCalendar.GetTimeUnitByScale(ATimeScale: TTimeScale): Integer;begin  case ATimeScale of    tsMinute:      Result := Minutes;    tsHour:      Result := Hours;    tsDay:      Result := Days;    tsWeek,tsWeekNum,tsWeekNumPlain:      Result := Weeks;    tsMonth:      Result := Monthes;    tsQuarter:      Result := Quarters;    tsHalfYear:      Result := HalfYears;    tsYear:      Result := Years;    else      Result := 0;  end;end;procedure TRoughCalendar.SetMajorColor(const Value: TColor);begin  FMajorColor := Value;  Repaint;end;procedure TRoughCalendar.SetMinorColor(const Value: TColor);begin  FMinorColor := Value;  Repaint;end;function TRoughCalendar.GetStartDrawIntervals: Integer;begin  Result := MajorScaleHeight + MinorScaleHeight;end;function TRoughCalendar.GetIntervalHeight: Integer;begin  Result := PixelsPerLine;end;function TRoughCalendar.GetIntervalWidth: Double;begin  Result := UnitsBetweenDates(VisibleStart,VisibleStart+1,MinorScale)*PixelsPerMinorScale;end;procedure TRoughCalendar.DrawHeaderLines;begin  with Canvas do  begin    Canvas.Pen.Style := psSolid;    Canvas.Pen.Color := clBlack;    MoveTo(0, MajorScaleHeight);    LineTo(ClientWidth, MajorScaleHeight);    MoveTo(0, MajorScaleHeight + MinorScaleHeight);    LineTo(ClientWidth, MajorScaleHeight + MinorScaleHeight);  end;end;procedure TRoughCalendar.DrawMinorScale;var  R, TextR: TRect;  OldTransparent: Integer;begin  with Canvas do  begin    if IsNewPeriod(MinorScale) then    begin      OldTransparent := SetBKMode(Handle, TRANSPARENT);      R.Left := {Trunc}Round        (          UnitsBetweenDates(VisibleStart, FCurrentDate, MinorScale)            *          PixelsPerMinorScale        );      R.Right := R.Left + PixelsPerMinorScale;      R.Top := MajorScaleHeight + 1;      R.Bottom := MajorScaleHeight + MinorScaleHeight - 1;      TextR := Rect(R.Left + 2, R.Top + 2, R.Right - 2, R.Bottom - 2);      DrawText      (        Handle,        PChar(GetTimeScaleName(MinorScale, FCurrentDate)),        -1,        TextR,        DT_LEFT or DT_VCENTER or DT_SINGLELINE      );      SetBKMode(Handle, OldTransparent);      Canvas.Pen.Style := psSolid;      Canvas.Pen.Color := clBlack;      MoveTo(R.Left, MajorScaleHeight);      LineTo(R.Left, MajorScaleHeight + MinorScaleHeight);    end;  end;end;procedure TRoughCalendar.DrawMajorScale;var  OldTransparent: Integer;  R: TRect;  TextR: TRect;begin  with Canvas do  begin    OldTransparent := SetBKMode(Handle, TRANSPARENT);    R.Left := {Trunc}Round      (        UnitsBetweenDates(VisibleStart, FCurrentDate, MinorScale)          *        PixelsPerMinorScale      );    R.Right := {Trunc}Round      (        UnitsBetweenDates(VisibleStart, IncTime(FCurrentDate, MajorScale, 1), MinorScale)          *        PixelsPerMinorScale      );    R.Top := 1;    R.Bottom := MajorScaleHeight - 1;    TextR := Rect(R.Left + 2, R.Top + 2, R.Right - 2, R.Bottom - 2);    DrawText    (      Handle,      PChar(GetTimeScaleName(MajorScale, FCurrentDate)),      -1,      TextR,      DT_LEFT or DT_VCENTER or DT_SINGLELINE or DT_LEFT    );    SetBKMode(Handle, OldTransparent);    Canvas.Pen.Style := psSolid;    Canvas.Pen.Color := clBlack;    MoveTo(R.Left, 0);    LineTo(R.Left, MajorScaleHeight);    Canvas.Pen.Style := psDot;    Canvas.Pen.Color := clWhite;    Canvas.Brush.Color := clBlack;    MoveTo(R.Left, MajorScaleHeight + MinorScaleHeight);    LineTo(R.Left, Height);  end;end;function TRoughCalendar.IsNewPeriod(AScale: TTimeScale; AUseSub: Boolean = False): Boolean;begin  case AScale of    tsMinute:      Result := Seconds = 0;    tsHour:      Result := (Minutes = 0) and (not AUseSub or AUseSub and IsNewPeriod(tsMinute, True));    tsDay:      Result := (Hours = 0) and (not AUseSub or AUseSub and IsNewPeriod(tsHour, True));    tsWeek,tsWeekNum,tsWeekNumPlain:      Result := (DayOfWeek = 1) and (not AUseSub or AUseSub and IsNewPeriod(tsDay, True));    tsMonth:      Result := (Days = 1) and (not AUseSub or AUseSub and IsNewPeriod(tsDay, True));    tsQuarter:      Result := ((Monthes - 1) mod 3 = 0) and (not AUseSub or AUseSub and IsNewPeriod(tsMonth, True));    tsHalfYear:      Result := ((Monthes - 1) mod 6 = 0) and (not AUseSub or AUseSub and IsNewPeriod(tsMonth, True));    tsYear:      Result := (Monthes = 1) and (not AUseSub or AUseSub and IsNewPeriod(tsMonth, True));    else      Result := True;  end;end;procedure TRoughCalendar.UpdateScrollbars;begin  if FVertScrollBar.Visible then  begin    RemoveControl(FVertScrollBar);    FVertScrollBar.Enabled := False;    FVertScrollBar.Visible := False;  end;  FHorzScrollBar.Enabled := True;  FHorzScrollBar.OnScroll := @DoOnHorzScroll;end;procedure TRoughCalendar.DoOnHorzScroll(Sender: TObject; ScrollCode: TScrollCode; var ScrollPos: Integer);var  R: TRect;begin  if (ScrollCode in [scLineUp, scPageUp, scEndScroll])  and (ScrollPos = 0)  and (FHorzScrollBar.Position = 0)  then    begin      if (ScrollCode = scLineUp) then        begin          FVisibleStart := ClearToPeriodStart(MinorScale, IncTime(FVisibleStart, MinorScale, -1));          Inc(FBeforeStartDateCount);          R := Rect(            0,            0,            Width - FVertScrollBar.Width * Integer(FVertScrollBar.Visible),            Height - FHorzScrollBar.Height * Integer(FHorzScrollBar.Visible)          );          InvalidateRect(Handle, @R, True);        end;    end  else    begin      if ClearToPeriodStart(MinorScale, FStartDate) > FVisibleStart then        begin          FVisibleStart := ClearToPeriodStart(MinorScale, IncTime(FVisibleStart, MinorScale, ScrollPos));          ScrollPos := ScrollPos - FBeforeStartDateCount;          if ScrollPos < 0 then          begin            FBeforeStartDateCount := Abs(ScrollPos);            ScrollPos := 0;          end;        end      else        begin          FVisibleStart := ClearToPeriodStart(MinorScale, IncTime(FStartDate, MinorScale, ScrollPos));          FBeforeStartDateCount := 0;        end;      if (ScrollCode <> scEndScroll) then        begin          R := Rect          (            0,            0,            Width - FVertScrollBar.Width * Integer(FVertScrollBar.Visible),            Height - FHorzScrollBar.Height * Integer(FHorzScrollBar.Visible)          );          InvalidateRect(Handle, @R, True);        end;      if ((ScrollCode = scPosition) and (FHorzScrollBar.Max - SCROLL_MAXSTEP < ScrollPos))      or ((ScrollCode in [scLineDown, scPageDown, scBottom]) and (FHorzScrollBar.Max = ScrollPos))      then        begin          FHorzScrollBar.Max := FHorzScrollBar.Max + SCROLL_MAXSTEP;          ScrollPos := FHorzScrollBar.Max - SCROLL_MAXSTEP;        end      else if (ScrollPos <= FHorzScrollBar.Max - SCROLL_MAXSTEP)           and (ScrollCode in [scLineUp, scPageUp, scPosition, scTop])           then        begin          if ScrollPos > SCROLL_MAX then            FHorzScrollBar.Max := FHorzScrollBar.Position          else            FHorzScrollBar.Max := SCROLL_MAX;        end;    end;end;procedure TRoughCalendar.WMSize(var Message: TLMSize);begin  UpdateScrollbars;  if FVertScrollBar.Visible then  begin    if FHorzScrollBar.Visible then      SetWindowPos      (        FVertScrollBar.Handle,        0,        Width - FVertScrollBar.Width,        0,        FVertScrollBar.Width,        Height - FHorzScrollBar.Height,        SWP_SHOWWINDOW or SWP_NOZORDER or  SWP_NOSENDCHANGING or SWP_NOACTIVATE      )    else      SetWindowPos      (        FVertScrollBar.Handle,        0,        Width - FVertScrollBar.Width,        0,        FVertScrollBar.Width,        Height,        SWP_SHOWWINDOW or SWP_NOZORDER or SWP_NOSENDCHANGING or SWP_NOACTIVATE      );  end;  if FHorzScrollBar.Visible then  begin    if FVertScrollBar.Visible then      SetWindowPos      (        FHorzScrollBar.Handle,        0,        0,        Height - FHorzScrollBar.Height,        Width - FVertScrollBar.Width,        FHorzScrollBar.Height,        SWP_SHOWWINDOW or SWP_NOZORDER or SWP_NOSENDCHANGING or SWP_NOACTIVATE      )    else      SetWindowPos      (        FHorzScrollBar.Handle,        0,        0,        Height - FHorzScrollBar.Height,        Width,        FHorzScrollBar.Height,        SWP_SHOWWINDOW or SWP_NOZORDER or SWP_NOSENDCHANGING or SWP_NOACTIVATE      );  end;  inherited;end;procedure TRoughCalendar.CMMouseEnter(var Message: TLMessage);begin  inherited;end;procedure TRoughCalendar.CMMouseLeave(var Message: TLMessage);begin  inherited;end;procedure TRoughCalendar.WMMouseMove(var Message: TLMMouseMove);beginend;procedure TRoughCalendar.WMLButtonDown(var Message: TLMLButtonDown);begin  inherited;end;procedure TRoughCalendar.WMLButtonUp(var Message: TLMRButtonDown);var  NewDate: TDateTime;  R: TRect;  I: Integer;begin  if Assigned(FDragInterval) and (FDragType <> ditNone) and FDragStarted then  begin    Canvas.Brush.Color := clWhite;    Canvas.DrawFocusRect(FDragRect);    Canvas.Brush.Color := clBlue;    Canvas.DrawFocusRect(      Rect(FDragRect.Left + 1, FDragRect.Top + 1, FDragRect.Right - 1, FDragRect.Bottom - 1));    case FDragType of      ditMiddle:      begin        if FDragInterval.IntervalType = itPeriod then        begin          R := FDragInterval.DoneRect;          FDragInterval.StartDate :=            IncTimeEx(VisibleStart, MinorScale, FDragRect.Left / PixelsPerMinorScale);          FDragInterval.FinishDate :=            IncTimeEx(VisibleStart, MinorScale, FDragRect.Right / PixelsPerMinorScale);          FDragInterval.IntervalDone :=            IncTimeEx            (              VisibleStart,              MinorScale,              (FDragRect.Left + (R.Right - R.Left)) / PixelsPerMinorScale            );        end else begin          FDragInterval.StartDate :=            IncTimeEx(              VisibleStart,              MinorScale,              (FDragRect.Left + (FDragRect.Right - FDragRect.Left) div 2) / PixelsPerMinorScale);          FDragInterval.FinishDate := FDragInterval.StartDate;        end;      end;      ditRightMove:      begin        NewDate :=          IncTimeEx(VisibleStart, MinorScale, FDragRect.Right / PixelsPerMinorScale);        if FDragInterval.StartDate > NewDate then          FDragInterval.FinishDate := FDragInterval.StartDate        else          FDragInterval.FinishDate := NewDate;      end;      ditLeftMove:      begin        NewDate := IncTimeEx(VisibleStart, MinorScale, FDragRect.Left / PixelsPerMinorScale);        if FDragInterval.FinishDate < NewDate then        begin          FDragInterval.StartDate := FDragInterval.FinishDate;        end else          FDragInterval.StartDate := NewDate;      end;      ditPercent:      begin        FDragInterval.IntervalDone :=          IncTimeEx(VisibleStart, MinorScale, FDragRect.Right / PixelsPerMinorScale);      end;      ditConnect:      begin        if FConnectInterval <> nil then        begin          for I := 0 to IntervalCount - 1 do            Interval[I].PrepareToUpdate;          FDragInterval.AddConnection(FConnectInterval,True);        end;      end;    end;    Cursor := crDefault;    Screen.Cursor := crDefault;    FConnectInterval := nil;    FConnectFromPoint := Point(-1, -1);    FConnectToPoint := Point(-1, -1);    FDragInterval := nil;    FDragType := ditNone;    FDragStarted := False;    FFromDragPoint := 0;    FDragRect := Rect(-1, -1, -1, -1);    FRough.UpdateInterval;  end;  inherited;end;{  ----------------------------------------  ------                            ------  ------      TRoughTree Class      ------  ------                            ------  ----------------------------------------}{TRoughTree}{  ***********************  ***   Public Part   ***  ***********************}{  ?????? ????????? ?????????.}constructor TRoughTree.Create(AnOwner: TRough);begin  inherited Create(AnOwner);  FRough := AnOwner;  FIntervals := FRough.FIntervals;  //ParentCtl3d := False;  //Ctl3d := False;  BorderStyle := bsNone;  DefaultDrawing := False;  ColCount := 8;  RowCount := 100;  DefaultColWidth := 40;  DefaultRowHeight := 24;  FIndent := 10;  Options :=  [    goFixedVertLine, goFixedHorzLine, goVertLine,    goHorzLine, {goEditing,} goColSizing  ];  FBranchFont := TFont.Create;  FBranchFont.Style := [fsBold];  Font.Style := [];  FEditInterval := nil;  if not (csDesigning in ComponentState) then  begin    FTextEdit := TEdit.Create(Owner);    (Owner as TWinControl).InsertControl(FTextEdit);    //FTextEdit.Ctl3D := False;    FTextEdit.BorderStyle := bsNone;    FTextEdit.Visible := False;    FTextEdit.OnKeyPress := @OnEditKeyPress;    FTextEdit.OnExit := @OnEditExit;    FDurationEdit := TSpinEdit.Create(Owner);    (Owner as TWinControl).InsertControl(FDurationEdit);    FDurationEdit.Visible := False;    FDurationEdit.OnExit := @OnEditExit;    FDateEdit := TDateEdit.Create(Owner);    (Owner as TWinControl).InsertControl(FDateEdit);    FDateEdit.Visible := False;    FDateEdit.OnExit := @OnEditExit;    FComboEdit := TComboBox.Create(Owner);    (Owner as TWinControl).InsertControl(FComboEdit);    FComboEdit.Visible := False;    FComboEdit.OnExit := @OnEditExit;    FUpDown := TUpDown.Create(Owner);    (Owner as TWinControl).InsertControl(FUpDown);    FUpDown.Visible := False;    FUpDown.OnExit := @OnEditExit;    FUpDown.OnClick := @OnUpDownButtonClick;    FMonthCalendar := TCalendar.Create(Owner);    (Owner as TWinControl).InsertControl(FMonthCalendar);    FMonthCalendar.Visible := False;    FMonthCalendar.AutoSize := True;    FMonthCalendar.OnExit := @OnEditExit;    FMonthCalendar.BorderWidth := 1;    //FMonthCalendar.CalColors.BackColor := clBlack;    FMonthCalendar.DisplaySettings:=[dsShowWeekNumbers,dsShowHeadings];    FMonthCalendar.OnChange := @OnMonthCalendarClick;    FDownButton := TSpeedButton.Create(Self);    FDownButton.GroupIndex := 1;    FDownButton.AllowAllUp := True;    InsertControl(FDownButton);    FDownButton.Visible := False;    //FDownButton.Glyph.Handle := LoadBitmap(0, MAKEINTRESOURCE(OBM_COMBO));    FDownButton.OnClick := @OnDownButtonClick;  end else begin    FTextEdit := nil;    FDurationEdit := nil;    FDateEdit := nil;    FComboEdit := nil;    FUpDown := nil;    FMonthCalendar := nil;    FDownButton := nil;  end;end;destructor TRoughTree.Destroy;begin  FBranchFont.Free;  inherited Destroy;end;{  **************************  ***   Protected Part   ***  **************************}procedure TRoughTree.CreateWnd;begin  inherited CreateWnd;  if not (csDesigning in ComponentState) then    UpdateCommonSettings;end;procedure TRoughTree.DrawCell(ACol, ARow: Longint; ARect: TRect;  AState: TGridDrawState);var  CurrInterval: TInterval;  DeltaX: Integer;  Stamp: TTimeStamp;  S: String;begin  inherited DrawCell(ACol, ARow, ARect, AState);  if csDesigning in ComponentState then Exit;  with Canvas do  begin    if gdFixed in AState then    begin      Brush.Color := FixedColor;      Canvas.Font := Self.Font;      WriteText(Canvas, ARect, 2, (ARect.Bottom - ARect.Top - TextHeight('A')) div 2,        Cells[ACol, ARow], taCenter, True);    end else begin      Brush.Color := Color;      CurrInterval := TInterval(Objects[0, ARow]);      if (CurrInterval <> nil) and CurrInterval.IsCollection then        Canvas.Font := FBranchFont      else        Canvas.Font := Self.Font;      if GetColumnType(ACol) = gctTask then      begin        if CurrInterval <> nil then        begin          DeltaX := (CurrInterval.Level - 1) * FIndent + 14;          WriteText          (            Canvas,            ARect,            DeltaX + 2,            (ARect.Bottom - ARect.Top - TextHeight('A')) div 2,            CurrInterval.Task,            taLeftJustify,            True          );          if CurrInterval.IsCollection then          begin            if CurrInterval.Opened then              DrawMinus              (                ARect.Left + DeltaX - 9,                ARect.Top + (ARect.Bottom - ARect.Top) div 2 - 5              )            else              DrawPlus              (                ARect.Left + DeltaX - 9,                ARect.Top + (ARect.Bottom - ARect.Top) div 2 - 5              );          end;        end else // ???? ??? ??? - ?????? ?????? ???????          FillRect(ARect);      end else if        (GetColumnType(ACol) = gctDuration)          and        (CurrInterval <> nil)      then begin        Stamp := CurrInterval.StampDuration;        S := IntToStr(Stamp.Date);        S := S + strDay;        WriteText        (          Canvas,          ARect,          2,          (ARect.Bottom - ARect.Top - TextHeight('A')) div 2,          S,          taLeftJustify,          True        );      end else if        (GetColumnType(ACol) = gctStart)          and        (CurrInterval <> nil)      then begin        WriteText        (          Canvas,          ARect,          2,          (ARect.Bottom - ARect.Top - TextHeight('A')) div 2,          DateToStr(CurrInterval.StartDate),          taLeftJustify,          True        );      end else if        (GetColumnType(ACol) = gctFinish)          and        (CurrInterval <> nil)      then begin        WriteText        (          Canvas,          ARect,          2,          (ARect.Bottom - ARect.Top - TextHeight('A')) div 2,          DateToStr(CurrInterval.FinishDate),          taLeftJustify,          True        );      end else        FillRect(ARect);      //////////////////////////////////////////      // ?????? ??????????, ???? ?????? ????????      DrawCellGrid(aCol,aRow,aRect,aState);      if gdSelected in AState then      begin        Brush.Color := clBlack;        FrameRect(ARect);        FrameRect(Rect(ARect.Left + 1, ARect.Top + 1, ARect.Right - 1, ARect.Bottom - 1));      end;    end;  end;end;{  ??????? ?????? ????. ?????????? ???????? ??? ??????? ????????.}procedure TRoughTree.MouseDown(Button: TMouseButton;  Shift: TShiftState; X, Y: Integer);var  CurrInterval: TInterval;  R: TRect;  ACol, ARow: Integer;begin  if csDesigning in ComponentState then Exit;  MouseToCell(X, Y, ACol, ARow);  R := CellRect(ACol, ARow);  CurrInterval := TInterval(Objects[0, ARow]);  if    (Button = mbLeft)      and    (GetColumnType(ACol) = gctTask)      and    (CurrInterval <> nil)  then begin    R.Left := R.Left + (CurrInterval.Level - 1) * FIndent + 5;    R.Right := R.Left + 9;    R.Top := R.Top + (R.Bottom - R.Top) div 2 - 5;    R.Bottom := R.Top + 9;    if IsInRect(X, Y, R) then    begin      CurrInterval.Opened := not CurrInterval.Opened;      FRough.UpdateInterval;    end else begin      if (ACol = Col) and (ARow = Row) then      begin        ShowTaskEditor;      end else        inherited MouseDown(Button, Shift, X, Y);    end;  end else    inherited MouseDown(Button, Shift, X, Y);end;function TRoughTree.SelectCell(ACol, ARow: Longint): Boolean;begin  Result := inherited SelectCell(ACol, ARow);  if not (csDesigning in ComponentState) then  begin    if Result then      UpdateCurrentControl(ACol, ARow)    else      UpdateCurrentControl(Col, Row);  end;    end;procedure TRoughTree.TopLeftChanged;var  I: Integer;begin  inherited TopLeftChanged;  if not (csDesigning in ComponentState) then    UpdateCurrentControl(Col, Row);  if not Assigned(FRough) then exit;  FRough.Calendar.Invalidate;end;procedure TRoughTree.ColWidthsChanged;begin  inherited ColWidthsChanged;  if not (csDesigning in ComponentState) then  begin    if Parent <> nil then      UpdateCurrentControl(Col, Row);  end;    end;procedure TRoughTree.DoExit;begin  if not (csDesigning in ComponentState) then  begin    FMonthCalendar.Visible := False;    FDownButton.Down := False;  end;    inherited DoExit;end;procedure TRoughTree.UpdateCommonSettings;var  I: Integer;begin  DefaultRowHeight := FRough.Calendar.PixelsPerLine;  RowHeights[0] :=    FRough.Calendar.MajorScaleHeight      +    FRough.Calendar.MajorScaleHeight;  Cells[0, 0] := strNum;  ColWidths[0] := 28;  Cells[1, 0] := strInfo;  ColWidths[1] := 37;  Cells[2, 0] := strTask;  ColWidths[2] := 115;  Cells[3, 0] := strTime;  ColWidths[3] := 55;  Cells[4, 0] := strStart;  ColWidths[4] := 73;  Cells[5, 0] := strFinish;  ColWidths[5] := 73;  Cells[6, 0] := strTies;  ColWidths[6] := 85;  Cells[7, 0] := strResourses;  ColWidths[7] := 85;  for I := 1 to RowCount - 1 do    Cells[0, I] := IntToStr(I);  UpdateTreeList;  if Assigned(FAfterUpdateCommonSettings) then    FAfterUpdateCommonSettings(Self);end;procedure TRoughTree.UpdateTreeList;var  List: TList;  I: Integer;begin  List := TList.Create;  try    FRough.MakeIntervalList(List);    RowCount := List.Count + 1;    for I := 0 to List.Count - 1 do      Objects[0, I + 1] := TObject(List[I]);    for I := List.Count + 1 to RowCount - 1 do      Objects[0, I] := nil;  finally    List.Free;  end;end;{  ************************  ***   Private Part   ***  ************************}function TRoughTree.GetColumnType(AnIndex: Integer): TRoughColumnType;begin  case AnIndex of    1: Result := gctInfo;    2: Result := gctTask;    3: Result := gctDuration;    4: Result := gctStart;    5: Result := gctFinish;    6: Result := gctConnection;    7: Result := gctResources;  else    Result := gctNone;  end;end;procedure TRoughTree.SetAfterUpdateCommonSettings(AValue: TNotifyEvent);begin  if FAfterUpdateCommonSettings=AValue then Exit;  FAfterUpdateCommonSettings:=AValue;end;procedure TRoughTree.SetIndent(const Value: Integer);begin  FIndent := Value;  Repaint;end;procedure TRoughTree.DrawMinus(X, Y: Integer);var  OldBrushColor, OldPenColor: TColor;begin  with Canvas do  begin    OldBrushColor := Brush.Color;    OldPenColor := Pen.Color;    Pen.Style := psSolid;    Pen.Color := clGray;    Brush.Color := clGray;    FrameRect(Rect(X, Y, X + 9, Y + 9));    Pen.Color := clBlack;    MoveTo(X + 2, Y + 4);    LineTo(X + 7, Y + 4);    Brush.Color := OldBrushColor;    Pen.Color := OldPenColor;  end;end;procedure TRoughTree.DrawPlus(X, Y: Integer);var  OldBrushColor, OldPenColor: TColor;begin  with Canvas do  begin    OldBrushColor := Brush.Color;    OldPenColor := Pen.Color;    Pen.Color := clGray;    Brush.Color := clGray;    FrameRect(Rect(X, Y, X + 9, Y + 9));    Pen.Color := clBlack;    MoveTo(X + 2, Y + 4);    LineTo(X + 7, Y + 4);    MoveTo(X + 4, Y + 2);    LineTo(X + 4, Y + 7);    Brush.Color := OldBrushColor;    Pen.Color := OldPenColor;  end;end;function TRoughTree.GetBrachFont: TFont;begin  Result := FBranchFont;end;procedure TRoughTree.SetBranchFont(const Value: TFont);begin  FBranchFont.Assign(Value);end;procedure TRoughTree.OnEditKeyPress(Sender: TObject; var Key: Char);var  R: TRect;  CurrInterval: TInterval;begin  R := CellRect(Col, Row);  CurrInterval := TInterval(Objects[0, Row]);  case Ord(Key) of    VK_ESCAPE:    begin      FTextEdit.Visible := False;      Key := #0;      SetFocus;    end;    VK_RETURN:    begin      CurrInterval.Task := FTextEdit.Text;      FTextEdit.Visible := False;      Key := #0;      SetFocus;    end;  end;end;procedure TRoughTree.OnEditExit(Sender: TObject);begin  if Sender = FTextEdit then  begin    if FTextEdit.Visible and Assigned(FEditInterval) then    begin      FEditInterval.Task := FTextEdit.Text;      FEditInterval := nil;      FTextEdit.Visible := False;    end;  end;end;procedure TRoughTree.OnDownButtonClick(Sender: TObject);var  R: TRect;  CurrInterval: TInterval;begin  SetFocus;  R := CellRect(Col, Row);  CurrInterval := TInterval(Objects[0, Row]);  if FDownButton.Down then  begin    if GetColumnType(Col) = gctStart then    begin      //FMonthCalendar.MinDate := EncodeDate(1900, 01, 01);      //FMonthCalendar.MaxDate := CurrInterval.FinishDate;      FMonthCalendar.DateTime := CurrInterval.StartDate;    end else begin      //FMonthCalendar.MinDate := CurrInterval.StartDate;      //FMonthCalendar.MaxDate := EncodeDate(9000, 01, 01);      FMonthCalendar.DateTime := CurrInterval.FinishDate;    end;    FMonthCalendar.SendToBack;    FMonthCalendar.Visible := True;    FMonthCalendar.Left := R.Right - FMonthCalendar.Width;    FMonthCalendar.Top := R.Bottom;    FMonthCalendar.BringToFront;  end else    FMonthCalendar.Visible := False;end;procedure TRoughTree.OnMonthCalendarClick(Sender: TObject);var  CurrInterval: TInterval;begin  CurrInterval := TInterval(Objects[0, Row]);  if CurrInterval <> nil then  begin    if GetColumnType(Col) = gctStart then    begin      CurrInterval.StartDate := FMonthCalendar.DateTime;    end else begin      CurrInterval.FinishDate := FMonthCalendar.DateTime;    end;    FRough.UpdateInterval;  end;  FMonthCalendar.Visible := False;  FDownButton.Down := False;end;procedure TRoughTree.OnUpDownButtonClick(Sender: TObject; Button: TUDBtnType);var  CurrInterval: TInterval;begin  CurrInterval := TInterval(Objects[0, Row]);  if CurrInterval <> nil then  begin    if Button = btNext then    begin      CurrInterval.Duration := CurrInterval.Duration + 1;    end else begin      if CurrInterval.StampDuration.Date > 0 then        CurrInterval.Duration := CurrInterval.Duration - 1;    end;    FRough.UpdateInterval;  end;end;procedure TRoughTree.UpdateCurrentControl(ACol, ARow: Integer);var  R: TRect;  CurrInterval: TInterval;  procedure HideAllControls;  begin    FTextEdit.Hide;    FDurationEdit.Hide;    FDateEdit.Hide;    FComboEdit.Hide;    FUpDown.Hide;    FMonthCalendar.Hide;    FDownButton.Hide;    FDownButton.Down := False;    //if CanFocus  then SetFocus;  end;begin  R := CellRect(ACol, ARow);  CurrInterval := TInterval(Objects[0, ARow]);  if not Assigned(FTextEdit) then exit;  if FTextEdit.Visible and Assigned(FEditInterval) then    FEditInterval.Task := FTextEdit.Text;  FEditInterval := nil;  HideAllControls;  case GetColumnType(ACol) of    gctDuration:    begin      FUpDown.Min := 0;      FUpDown.Max := 32767;      if CurrInterval <> nil then      begin        FUpDown.Position := CurrInterval.StampDuration.Date;        FUpDown.Enabled := not CurrInterval.IsCollection;      end else begin        FUpDown.Position := 0;        FUpDown.Enabled := False;      end;      FUpDown.Height := R.Bottom - R.Top - 4;      FUpDown.Width := 16;      FUpDown.Left := R.Right - 16 - 2;      FUpDown.Top := R.Top + 2;      FUpDown.Visible := True;      FUpDown.BringToFront;      FEditInterval := CurrInterval;    end;    gctStart, gctFinish:    begin      if CurrInterval <> nil then      begin        FDownButton.Enabled := not CurrInterval.IsCollection;        FEditInterval := CurrInterval;      end else begin        FDownButton.Enabled := False;        FEditInterval := nil;      end;      FDownButton.Height := R.Bottom - R.Top - 4;      FDownButton.Width := 16;      FDownButton.Left := R.Right - 16 - 2;      FDownButton.Top := R.Top + 2;      FDownButton.Visible := True;      FDownButton.BringToFront;    end;    else begin      HideAllControls;      FEditInterval := nil;    end;  end;end;procedure TRoughTree.ShowTaskEditor;var  R: TRect;  CurrInterval: TInterval;begin  R := CellRect(Col, Row);  CurrInterval := TInterval(Objects[0, Row]);  if CurrInterval <> nil then  begin    FTextEdit.SendToBack;    FTextEdit.Visible := True;    FTextEdit.AutoSize := False;    FTextEdit.Left := R.Left + 2;    FTextEdit.Top := R.Top + 2;    FTextEdit.Width := R.Right - R.Left - 4;    FTextEdit.Height := R.Bottom - R.Top - 4;    FTextEdit.Text := CurrInterval.Task;    FTextEdit.SelectAll;    FTextEdit.BringToFront;    FTextEdit.SetFocus;    FEditInterval := CurrInterval;  end;  end;procedure TRoughTree.WMChar(var Message: TLMChar);begin  if GetColumnType(Col) = gctTask then  begin    if Message.CharCode = VK_ESCAPE then    begin      FTextEdit.Visible := False;      SetFocus;    end else if not FTextEdit.Visible then    begin      ShowTaskEditor;    end;    SendMessage(FTextEdit.HANDLE, LM_CHAR, Message.CharCode, Message.KeyData);  end //else    //inherited ;end;constructor TgsRough.Create(AnOwner: TComponent);begin  inherited Create(AnOwner);  Width := 300;  Height := 150;  FIntervals := TList.Create;  FTree := TRoughTree.Create(Self);  InsertControl(FTree);  FTree.Align := alLeft;  FTree.Width := 200;  FSplitter := TSplitter.Create(Self);  InsertControl(FSplitter);  FSplitter.Left := FTree.Left + FTree.Width + 1;  FSplitter.Align := alLeft;  FSplitter.Width := 6;  FSplitter.Beveled := True;  FCalendar := TRoughCalendar.Create(Self);  InsertControl(FCalendar);  FCalendar.Align := alClient;end;destructor TgsRough.Destroy;begin  FCalendar.Free;  FTree.Free;  FSplitter.Free;  FIntervals.Free;  inherited Destroy;end;procedure TgsRough.AddInterval(AnInterval: TInterval);begin  FIntervals.Add(AnInterval);  UpdateInterval;end;procedure TgsRough.InsertInterval(AnIndex: Integer; AnInterval: TInterval);begin  FIntervals.Insert(AnIndex, AnInterval);  UpdateInterval;end;procedure TgsRough.DeleteInterval(AnIndex: Integer);begin  FIntervals.Delete(AnIndex);  UpdateInterval;end;procedure TgsRough.RemoveInterval(AnInterval: TInterval);begin  FIntervals.Remove(AnInterval);  UpdateInterval;end;{DONE 3 -oDenis -cMainUpdate: ??????????}procedure TgsRough.UpdateInterval;begin  if IsUpdating then exit;  FTree.UpdateTreeList;  FTree.Repaint;  FCalendar.Repaint;end;procedure TgsRough.BeginUpdate;begin  inc(FUpdateCount);end;function TgsRough.IsUpdating: Boolean;begin  Result := FUpdateCount>0;end;procedure TgsRough.EndUpdate;begin  dec(FUpdateCount);  if FUpdateCount <=0 then    UpdateInterval;end;{  **************************  ***   Protected Part   ***  **************************}procedure TgsRough.MakeIntervalList(AList: TList);var  I: Integer;begin  for I := 0 to IntervalCount - 1 do  begin    if Interval[I].Visible then    begin      AList.Add(Interval[I]);      Interval[I].MakeIntervalList(AList);    end;  end;end;{  ************************  ***   Private Part   ***  ************************}function TgsRough.GetIntervalCount: Integer;begin  Result := FIntervals.Count;end;function TgsRough.GetInterval(AnIndex: Integer): TInterval;begin  Result := TInterval(FIntervals[AnIndex]);end;function TgsRough.GetCalendarFont: TFont;begin  Result := FCalendar.Font;end;procedure TgsRough.SetCalendarFont(const Value: TFont);begin  FCalendar.Font := Value;end;function TgsRough.GetCalendarColor: TColor;begin  Result := FCalendar.Color;end;procedure TgsRough.SetCalendarColor(const Value: TColor);begin  FCalendar.Color := Value;end;function TgsRough.GetMajorColor: TColor;begin  Result := FCalendar.MajorColor;end;procedure TgsRough.SetMajorColor(const Value: TColor);begin  FCalendar.MajorColor := Value;end;function TgsRough.GetMinorColor: TColor;begin  Result := FCalendar.MinorColor;end;procedure TgsRough.SetMinorColor(const Value: TColor);begin  FCalendar.MinorColor := Value;end;function TgsRough.GetMajorScale: TTimeScale;begin  Result := FCalendar.MajorScale;end;procedure TgsRough.SetMajorScale(const Value: TTimeScale);begin  FCalendar.MajorScale := Value;end;function TgsRough.GetMinorScale: TTimeScale;begin  Result := FCalendar.MinorScale;end;procedure TgsRough.SetMinorScale(const Value: TTimeScale);begin  FCalendar.MinorScale := Value;end;function TgsRough.GetPixelsPerMinorScale: Integer;begin  Result := FCalendar.PixelsPerMinorScale;end;procedure TgsRough.SetPixelsPerMinorScale(const Value: Integer);begin  FCalendar.PixelsPerMinorScale := Value;end;function TgsRough.GetPixelsPerLine: Integer;begin  Result := FCalendar.PixelsPerLine;end;procedure TgsRough.SetPixelsPerLine(const Value: Integer);begin  FCalendar.PixelsPerLine := Value;end;function TgsRough.GetStartDate: TDateTime;begin  Result := FCalendar.StartDate;end;procedure TgsRough.SetStartDate(const Value: TDateTime);begin  FCalendar.StartDate := Value;  FCalendar.FHorzScrollBar.Position:=trunc(StartDate-Value);end;function TgsRough.GetTreeIndent: Integer;begin  Result := FTree.Indent;end;procedure TgsRough.SetTreeIndent(const Value: Integer);begin  FTree.Indent := Value;end;function TgsRough.GetTreeFont: TFont;begin  Result := FTree.Font;end;procedure TgsRough.SetTreeFont(const Value: TFont);begin  FTree.Font := Value;end;function TgsRough.GetTreeBranchFont: TFont;begin  Result := FTree.BranchFont;end;procedure TgsRough.SetTreeBranchFont(const Value: TFont);begin  FTree.BranchFont := Value;end;initialization  Screen.Cursors[crRoughMiddle] := LoadCursor(hInstance, 'GANTT_MIDDLE');  Screen.Cursors[crRoughRightMove] := LoadCursor(hInstance, 'GANTT_RIGHTMOVE');  Screen.Cursors[crRoughLeftMove] := LoadCursor(hInstance, 'GANTT_LEFTMOVE');  Screen.Cursors[crRoughPercent] := LoadCursor(hInstance, 'GANTT_PERCENT');  Screen.Cursors[crRoughConnect] := LoadCursor(hInstance, 'GANTT_CONNECT');  DrawBitmap := TBitmap.Create;finalization  DrawBitmap.Free;end.